# 🚀 Go의 제네릭(Generic) 프로그래밍 완벽 정리

## ✅ **1. Go 1.18부터 제네릭 지원**
Go는 **1.18 버전부터 제네릭(Generic)**을 공식적으로 지원하게 되었습니다.  
제네릭을 사용하면 **여러 타입에서 동작하는 함수를 하나의 코드로 작성할 수 있습니다.**  

기존에는 Go가 **강타입 언어(Strongly Typed Language)**이기 때문에,  
다양한 타입을 지원하는 함수를 만들려면 **각 타입별로 별도 함수**를 작성해야 했습니다.  

---

## 🎯 **2. 왜 제네릭 프로그래밍이 필요한가?**
### 🔹 **기존 방식의 문제점**
Go는 강타입 언어이므로, 같은 기능을 하는 함수라도 **타입별로 별도 구현**해야 했습니다.

예를 들어, 두 숫자를 더하는 함수를 만든다고 가정하면:

```go
func AddInt(a, b int) int {
    return a + b
}

func AddFloat(a, b float64) float64 {
    return a + b
}
```
- `int`와 `float64`를 처리하는 함수가 각각 필요함 → **중복 코드 증가**
- 새로운 타입(`int64`, `uint`, `complex128`)이 필요하면? → **계속 새로운 함수 추가해야 함**

### ✅ **제네릭을 사용하면 해결!**
Go 1.18부터는 **제네릭(Generic)**을 사용해 **하나의 함수로 여러 타입을 지원**할 수 있습니다.

```go
func Add[T int | float64](a, b T) T {
    return a + b
}
```
- `T`는 **제네릭 타입 매개변수**
- `T int | float64` → `int` 또는 `float64` 타입만 허용
- 이제 `int`, `float64` 모두 사용 가능!

```go
fmt.Println(Add(3, 5))      // ✅ 정수 연산 가능
fmt.Println(Add(2.5, 1.5))  // ✅ 실수 연산 가능
```
💡 **코드 중복이 사라지고, 더 유연한 함수 설계가 가능해짐!** 🎉

---

## ⚖️ **3. `interface{}` vs. 제네릭 타입 제한자 비교**
### 🔹 **기존 `interface{}` 사용 방식**
제네릭이 없던 시절, Go에서는 `interface{}`를 사용하여 다양한 타입을 처리했습니다.

```go
func Add(a, b interface{}) interface{} {
    return a.(int) + b.(int)  // 타입 변환 필요 ❌
}
```
- `interface{}`는 **모든 타입을 허용**하지만, 내부적으로 **타입 변환(type assertion)**을 해야 함 → **런타임 오류 위험**
- `Add(3.5, 2.5)`와 같은 코드에서 **컴파일 시점이 아니라 런타임에 오류 발생**

### ✅ **제네릭 타입 제한자의 장점**
제네릭에서는 **타입 제한자(Type Constraint)**를 사용하여 특정 타입만 허용할 수 있습니다.

```go
func Add[T int | float64](a, b T) T {
    return a + b
}
```
- `T`는 `int` 또는 `float64` 타입만 받을 수 있음
- **컴파일 타임에서 타입 검사를 수행** → **안전하고 성능도 좋음**
- 불필요한 타입 변환이 없으므로 **런타임 오버헤드 감소**

📌 **결론: `interface{}`는 모든 타입을 받지만, 런타임에서 타입을 검사해야 함.  
제네릭은 컴파일 타임에 타입을 검사하므로 더 안전하고 성능도 뛰어남!**

---

## 🏆 **4. 최신 Go 버전에서 제네릭 사용하는 방법**
### ✅ 1) **여러 타입 지원**
```go
func Add[T int | float64 | string](a, b T) T {
    return a + b
}
```
✔️ `int`, `float64`, `string` 타입에서만 작동  
✔️ 불필요한 타입 변환 없이 안전하게 사용 가능  

---

### ✅ 2) **사용자 정의 타입 지원 (`~` 연산자)**
```go
type MyInt int

func Add[T ~int | ~float64](a, b T) T {
    return a + b
}
```
✔️ `~int`는 `int`뿐만 아니라 `type MyInt int` 같은 **사용자 정의 타입**도 허용  
✔️ Go의 타입 시스템을 더 유연하게 활용 가능  

---

## 🆕 **5. Go 1.21에서 추가된 제네릭 지원 패키지 (`slices` 및 `maps`)**
Go 1.21에서는 기본 패키지에 **제네릭을 활용한 `slices`와 `maps` 패키지**가 추가되었습니다.

### ✅ **slices 패키지 활용 예시**
```go
import "slices"

numbers := []int{3, 1, 4, 1, 5, 9}
slices.Sort(numbers)  // ✅ 정렬 기능 제공
fmt.Println(numbers)   // 출력: [1 1 3 4 5 9]
```
✔️ `slices.Sort`는 제네릭을 사용해 모든 비교 가능한 타입을 정렬 가능

### ✅ **maps 패키지 활용 예시**
```go
import "maps"

m := map[string]int{"a": 1, "b": 2, "c": 3}
keys := maps.Keys(m)   // ✅ 맵의 키를 추출
fmt.Println(keys)      // 출력: ["a" "b" "c"]
```
✔️ `maps.Keys`는 맵의 키들을 슬라이스 형태로 반환

💡 **Go 1.21부터는 `slices`와 `maps` 패키지를 사용하여 더욱 편리한 제네릭 기능을 활용할 수 있습니다!** 🚀

---

## 🎯 **6. 결론 및 요약**
| 기능 | `interface{}` | 제네릭 (`T any`, 타입 제한자) |
|------|--------------|------------------------------|
| **타입 검증** | 런타임 검사 | 컴파일 타임 검사 |
| **타입 변환 필요** | O (타입 단언 필요) | X |
| **성능** | 비교적 느림 | 빠름 |
| **유연성** | 모든 타입 허용 (오류 위험) | 특정 타입만 허용 |

✅ 제네릭을 사용하면 **컴파일 타임에서 타입 검사가 가능**하여,  
런타임 오류를 방지하고 성능도 향상됩니다. 🚀

---
### 💡 **Go에서 제네릭을 사용하면**
✔️ 코드 중복을 줄이고  
✔️ 더 안전한 타입 검사를 수행하며  
✔️ 성능도 향상시킬 수 있습니다.  
