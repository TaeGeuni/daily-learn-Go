## **SOLID란?**  
SOLID는 객체지향 설계의 5가지 원칙을 의미하는 약어로, 유지보수성과 확장성을 높이는 데 도움을 줍니다.  

### 1. **단일 책임 원칙 (Single Responsibility Principle, SRP)**  
- 하나의 클래스는 하나의 책임만 가져야 합니다.  
- 변경이 필요한 이유가 단 하나여야 하며, 여러 기능을 동시에 처리하지 않도록 해야 합니다.  

### 2. **개방-폐쇄 원칙 (Open-Closed Principle, OCP)**  
- 기존 코드를 수정하지 않고도 확장이 가능해야 합니다.  
- 새로운 기능을 추가할 때 기존 코드를 변경하지 않고, 확장할 수 있도록 설계해야 합니다.  

### 3. **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**  
- 자식 클래스는 부모 클래스를 대체하여 사용할 수 있어야 합니다.  
- 즉, 프로그램에서 부모 클래스를 사용하는 부분을 자식 클래스로 대체해도 정상적으로 동작해야 합니다.  

### 4. **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**  
- 클라이언트가 자신이 사용하지 않는 기능에 의존하지 않도록 인터페이스를 분리해야 합니다.  
- 하나의 거대한 인터페이스보다는 특정 기능별로 인터페이스를 나누는 것이 좋습니다.  

### 5. **의존 관계 역전 원칙 (Dependency Inversion Principle, DIP)**  
- 고수준 모듈이 저수준 모듈에 의존하는 것이 아니라, 추상화(인터페이스)에 의존해야 합니다.  
- 이를 통해 변화에 유연한 구조를 만들 수 있습니다.  

---

## **나쁜 설계란?**  

### 1. **경직성 (Rigidity)**  
- 모듈 간 결합도(Coupling)가 너무 높아 코드 변경이 어렵습니다.  
- 의존 관계가 복잡하게 얽혀 있어, 어느 부분을 수정해야 할지 모를 정도로 유지보수가 어렵습니다.  

### 2. **부서지기 쉬움 (Fragility)**  
- 한 부분을 변경했을 때, 예상하지 못한 다른 부분이 함께 망가지는 경우입니다.  
- 이런 상황이 발생하면 코드 변경이 부담스러워지고, 안정적인 프로그램 유지가 어렵습니다.  

### 3. **부동성 (Immobility)**  
- 특정 기능을 다른 프로젝트에서 재사용하고 싶어도 결합도가 너무 높아 독립적으로 옮길 수 없습니다.  
- 결과적으로 코드 재사용성이 낮아지고, 같은 기능을 반복적으로 새로 구현해야 하는 문제가 발생합니다.
