# Golang 함수 고급편

Go 언어에서 함수는 단순한 호출 대상 이상의 역할을 합니다. 이번 글에서는 Go의 고급 함수 개념들에 대해 살펴보고, 각각의 특징과 활용 사례를 정리합니다.

---

## 1. 가변 인수 함수 (Variadic Functions)

- **개념:**  
  함수의 매개변수를 고정된 개수가 아닌 **가변적인 개수**로 받을 수 있게 해줍니다.

- **문법:**  
  매개변수 타입 앞에 `...` (ellipsis)를 붙입니다.
  
  ```go
  func sum(numbers ...int) int {
      total := 0
      for _, n := range numbers {
          total += n
      }
      return total
  }
  ```

- **사용 사례:**  
  여러 개의 값을 하나의 함수로 전달할 때, 인자의 개수가 동적으로 변할 수 있는 경우에 유용합니다.

---

## 2. defer 지연 실행 (Deferred Execution)

- **개념:**  
  `defer` 명령문은 해당 함수의 **종료 직전에** 특정 코드를 실행하도록 예약합니다.  
  주로 파일, 네트워크 연결, 데이터베이스 연결 등과 같이 외부 자원을 해제할 때 사용됩니다.

- **문법 예시:**
  ```go
  func processFile() {
      f, err := os.Open("data.txt")
      if err != nil {
          log.Fatal(err)
      }
      defer f.Close() // 함수 종료 직전에 파일 닫기
      // ... 파일 처리 로직 ...
  }
  ```

- **주의사항:**  
  `defer`는 선언된 **순서의 역순**으로 실행됩니다. 즉, 마지막에 선언된 defer가 먼저 실행됩니다.

---

## 3. 함수 타입 변수 (Function Variables)

- **개념:**  
  Go에서는 함수를 **값**으로 취급합니다. 따라서 함수 자체를 변수에 저장하거나 다른 함수에 인자로 전달할 수 있습니다.

- **세부 설명:**
  - **함수도 값이다:**  
    함수는 메모리 상에서 시작 주소(또는 함수 포인터)를 가지고 있으므로, 다른 값들처럼 변수에 할당하거나 전달할 수 있습니다.
  - **함수 시그니처 (Function Signature):**  
    함수 타입은 함수의 이름이나 구현부를 제외한 **매개변수와 반환 값의 타입**으로 표현됩니다.
    
    ```go
    // 함수 정의
    func add(a, b int) int {
        return a + b
    }
    // 함수 시그니처: func(int, int) int
    ```

- **활용:**  
  고차 함수(High-order functions)를 구현할 때, 콜백 함수나 전략 패턴을 사용할 때 유용합니다.

---

## 4. 함수 리터럴 (람다, Function Literals / Closures)

- **개념:**  
  함수 리터럴은 **익명 함수**를 정의하는 방식입니다. 이를 통해 함수를 값으로 바로 생성하여 변수에 할당하거나 인자로 전달할 수 있습니다.

- **문법 예시:**
  ```go
  f := func(a, b int) int {
      return a + b
  }
  fmt.Println(f(2, 3)) // 5 출력
  ```

- **클로저(Closure)의 특징:**
  - **내부 상태 캡처:**  
    함수 리터럴은 **외부 스코프의 변수**를 캡처하여 사용할 수 있습니다. 이 때, 값 복사가 아니라 **레퍼런스(참조)**를 복사하는 형태로 동작하여, 외부 변수의 상태 변화를 반영합니다.
  - **상태 유지:**  
    일반 함수는 호출 시에만 동작하지만, 클로저는 캡처한 외부 변수의 상태를 기억하고 변경할 수 있습니다.
  
- **예시:**
  ```go
  func counter() func() int {
      i := 0
      return func() int {
          i++ // 외부 변수 i를 캡처하여 상태를 유지
          return i
      }
  }

  func main() {
      c := counter()
      fmt.Println(c()) // 1
      fmt.Println(c()) // 2
  }
  ```

---

## 5. 의존성 주입 (Dependency Injection)

- **개념:**  
  의존성 주입은 **외부에서 필요한 로직이나 자원을 주입**하는 방식입니다. 이를 통해 함수나 모듈이 특정 구현에 의존하지 않고, 유연하고 테스트하기 쉬운 구조를 만들 수 있습니다.

- **예시:**  
  아래 예제에서는 파일에 출력을 하는 함수를 추상화하여, 출력 로직을 외부에서 주입합니다.
  ```go
  package main

  import (
      "fmt"
      "os"
  )

  type Writer func(string)

  func writeHello(writer Writer) {
      writer("Hello World")
  }

  func main() {
      f, err := os.Create("test.txt")
      if err != nil {
          fmt.Println("Failed to create a file")
          return
      }
      defer f.Close()

      // 클로저를 통해 외부 변수 f를 캡처하고, writeHello에 전달
      writeHello(func(msg string) {
          fmt.Fprintln(f, msg)
      })
  }
  ```

- **장점:**
  - **테스트 용이성:**  
    의존성을 외부에서 주입하면, 테스트 시 모의 객체(mock)나 다른 구현체를 사용할 수 있습니다.
  - **유연성:**  
    구현체를 변경할 때 해당 함수의 내부 코드를 수정하지 않아도 됩니다.

---

## 마무리

Go 언어에서 함수는 단순한 호출 대상 이상으로 다양한 방식으로 활용할 수 있습니다.  
- **가변 인수 함수**는 동적인 인자 처리를 가능하게 하고,  
- **defer**는 자원 해제와 같은 정리 작업을 안전하게 보장하며,  
- **함수 타입 변수**와 **함수 리터럴(클로저)**는 함수를 값처럼 다루어 높은 수준의 추상화와 유연성을 제공합니다.  
- 마지막으로, **의존성 주입**을 통해 코드의 결합도를 낮추고 테스트 용이성을 높일 수 있습니다.
