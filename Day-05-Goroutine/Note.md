```markdown
# Go 고루틴과 동시성 프로그래밍 정리

## 1. 스레드와 CPU

### 스레드(Thread)
- 프로그램 내에서 **실행 흐름의 단위**를 의미한다.

### CPU
- 연산을 수행하는 하드웨어 장치로, 본질적으로 **단순 계산기** 역할을 한다.
- 실제 스레드 관리와 스케줄링은 **운영체제(OS)**가 담당한다.

> "스레드"나 "고루틴" 내부의 세부 동작보다는 OS가 제공하는 매직 덕분에 우리가 편리하게 병행 처리를 할 수 있다.

---

## 2. 컨텍스트 스위칭 (Context Switching)

### 컨텍스트 스위칭이란?
- 하나의 스레드(혹은 프로세스)에서 다른 스레드로 전환할 때, 현재 상태(레지스터 값, 스택 등)를 저장하고 새 스레드의 상태를 복원하는 과정이다.
- 이 과정에는 **오버헤드(비용)**가 발생한다.

### 스레드 수와 코어 수
- **스레드 수가 코어 수와 같으면** 불필요한 컨텍스트 스위칭이 줄어들어 효율적일 수 있다.
- 그러나 실제로는 I/O 차단이나 우선순위 등 다양한 이유로 **코어 수와 동일해도** 컨텍스트 스위칭이 발생할 수 있다.

---

## 3. 고루틴 (Goroutine)

### 고루틴의 기본 개념
- Go 프로그램의 모든 실행은 **고루틴** 단위로 이루어진다.
- `main()` 함수도 **메인 고루틴**으로 실행된다.
- 새로운 고루틴은 `go 함수()` 형태의 호출로 생성된다.

### 고루틴의 동작 원리
- 고루틴은 OS 스레드 위에서 실행되는 **경량(green) 스레드**이다.
- Go 런타임은 수많은 고루틴을 소수의 OS 스레드에 **효율적으로 매핑(multiplexing)**하여 실행한다.

### 실행 예시
- **코어 1**에서 **OS 스레드 1**이 **고루틴 1**을 실행하고,
- **코어 2**에서 **OS 스레드 2**가 **고루틴 2**를 실행하며,
- 실행 대기 중인 다른 고루틴(예: 고루틴 3, 고루틴 4)은 **대기 큐**에 머물다가 OS 스레드가 사용 가능해지면 실행된다.

---

## 4. 동시성 프로그래밍 시 주의사항

### 공유 메모리 접근 문제
- 여러 고루틴이 **동일한 메모리 자원**에 동시에 접근하면, 데이터 경합(data race)이나 예기치 않은 동작이 발생할 수 있다.

### 해결 방법
1. **잠금(Lock) 사용**
   - `sync.Mutex` 등을 사용해 공유 자원에 한 번에 한 고루틴만 접근하도록 제한한다.
   
2. **채널(Channel)을 통한 통신**
   - Go에서는 **공유 메모리를 직접 다루기보다는** 채널을 통해 데이터를 주고받으며 동시성을 관리하는 방식을 권장한다.

> **데이터는 한 곳에서 소유하고, 필요 시 메시지를 전달하자** (Go의 동시성 철학)

---

## 5. 뮤텍스 (Mutex)와 그 사용 시 주의점

### 뮤텍스의 역할
- 공유 자원에 대한 접근을 **한 번에 하나의 고루틴만 허용**하여 데이터 경합을 방지한다.

### 뮤텍스 사용의 단점
- **과도한 락 사용**: 필요 이상으로 락을 사용하면 고루틴들이 순차적으로 실행되어 동시성의 이점을 잃고 성능이 저하될 수 있다.
- **데드락(Deadlock) 위험**: 여러 뮤텍스를 잘못된 순서로 사용하면 고루틴들이 서로 락 해제를 기다리며 무한 대기 상태에 빠질 수 있다.

### 결론
- 뮤텍스는 **필요한 경우에만 신중하게 사용**해야 한다.
- 상황에 따라서는 **채널**이나 다른 동시성 패턴을 활용하는 것이 더 효과적이다.

---

## 6. 대안 및 자원 관리 기법

### 1. 영역(Area) 분리
- 데이터를 사용하는 영역을 명확하게 분리하여, 여러 고루틴이 동시에 접근하지 않도록 설계한다.

### 2. 역할(Role) 분리
- 각 고루틴이 특정 역할만 수행하도록 하여, 데이터 공유를 최소화하고 안전하게 처리한다.

### 3. 메시지 전달 방식
- **채널(Channel)을 활용**하여 고루틴 간에 데이터를 주고받으며, 공유 메모리 접근을 줄인다.
